<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âš“ Batalla Naval 2.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #0a1929;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #0a4d68 0%, #1b6b93 50%, #2d8bba 100%);
        }

        #menuScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 60px 80px;
            border-radius: 25px;
            text-align: center;
            z-index: 30;
            border: 4px solid #3b82f6;
            box-shadow: 0 0 60px rgba(59, 130, 246, 0.6);
        }

        #menuScreen h1 {
            font-size: 72px;
            margin-bottom: 30px;
            color: #60a5fa;
            text-shadow: 0 0 30px #3b82f6;
        }

        .menu-button {
            display: block;
            width: 320px;
            margin: 20px auto;
            padding: 22px 45px;
            font-size: 28px;
            background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 6px 25px rgba(59, 130, 246, 0.5);
        }

        .menu-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 12px 40px rgba(59, 130, 246, 0.8);
        }

        .menu-button.secondary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 6px 25px rgba(16, 185, 129, 0.5);
        }

        .menu-button.secondary:hover {
            box-shadow: 0 12px 40px rgba(16, 185, 129, 0.8);
        }

        #ui {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            display: none;
            flex-direction: row;
            gap: 30px;
            justify-content: center;
        }

        .player-info {
            background: rgba(0, 0, 0, 0.85);
            padding: 25px 35px;
            border-radius: 18px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            min-width: 220px;
        }

        .player-name {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 12px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.9);
        }

        .player-health {
            font-size: 22px;
            margin-bottom: 8px;
        }

        .health-bar {
            width: 200px;
            height: 24px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            overflow: hidden;
            margin: 12px auto 0;
            border: 3px solid rgba(255, 255, 255, 0.6);
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444 0%, #f59e0b 50%, #22c55e 100%);
            transition: width 0.3s ease;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.8);
        }

        #score {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            background: rgba(0, 0, 0, 0.85);
            padding: 18px 45px;
            border-radius: 18px;
            display: none;
            border: 3px solid #fbbf24;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            font-weight: bold;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px 75px;
            border-radius: 25px;
            text-align: center;
            color: white;
            display: none;
            z-index: 20;
            border: 4px solid #fbbf24;
            box-shadow: 0 0 60px rgba(251, 191, 36, 0.6);
        }

        #gameOver h1 {
            font-size: 56px;
            margin-bottom: 25px;
            color: #fbbf24;
            text-shadow: 0 0 25px rgba(251, 191, 36, 0.8);
        }

        #gameOver p {
            font-size: 22px;
            margin: 12px 0;
        }

        #gameOver button {
            margin: 15px 12px;
            padding: 18px 42px;
            font-size: 22px;
            background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        #gameOver button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 35px rgba(59, 130, 246, 0.9);
        }

        #controls {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 22px 45px;
            border-radius: 18px;
            color: white;
            font-size: 18px;
            text-align: center;
            border: 3px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            display: none;
        }

        .control-group strong {
            color: #fbbf24;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="menuScreen">
        <h1>âš“ BATALLA NAVAL âš“</h1>
        <button class="menu-button" onclick="startGame('single')">ðŸŽ® 1 Jugador</button>
        <button class="menu-button secondary" onclick="startGame('multi')">ðŸ‘¥ 2 Jugadores</button>
    </div>

    <div id="ui">
        <div class="player-info" id="player1Info">
            <div class="player-name" style="color: #3b82f6;">Jugador 1</div>
            <div class="player-health">Vida: <span id="p1Health">100</span></div>
            <div class="health-bar">
                <div class="health-fill" id="p1HealthBar" style="width: 100%;"></div>
            </div>
        </div>
        <div class="player-info" id="player2Info">
            <div class="player-name" style="color: #ef4444;">Jugador 2</div>
            <div class="player-health">Vida: <span id="p2Health">100</span></div>
            <div class="health-bar">
                <div class="health-fill" id="p2HealthBar" style="width: 100%;"></div>
            </div>
        </div>
    </div>

    <div id="score">
        PuntuaciÃ³n: <span id="scoreValue">0</span> | Enemigos: <span id="enemiesKilled">0</span>
    </div>

    <div id="gameOver">
        <h1 id="winnerText"></h1>
        <p id="gameOverStats"></p>
        <button onclick="restartGame()">Jugar de Nuevo</button>
        <button onclick="backToMenu()">MenÃº Principal</button>
    </div>

    <div id="controls">
        <div class="control-group" id="controls1J" style="display: none;">
            <strong>Controles:</strong> WASD para moverse | ESPACIO para disparar
        </div>
        <div class="control-group" id="controls2J" style="display: none;">
            <strong>Jugador 1:</strong> WASD + ESPACIO | <strong>Jugador 2:</strong> Flechas + ENTER
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let gameMode = null;
        let gameActive = false;
        let score = 0;
        let enemiesKilled = 0;
        let player1 = null;
        let player2 = null;
        let enemies = [];
        let obstacles = [];
        let powerUps = [];
        let particles = [];
        let lastEnemySpawn = 0;
        let lastPowerUpSpawn = 0;

        const keys = {};
        const config = {
            shipSpeed: 4,
            bulletSpeed: 10,
            bulletDamage: 10,
            fireRate: 250,
            enemySpawnRate: 2500,
            powerUpSpawnRate: 8000
        };

        // Clase Particle
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.life = 1;
                this.size = Math.random() * 4 + 2;
                this.color = color;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.025;
            }

            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Clase Bullet
        class Bullet {
            constructor(x, y, angle, owner) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = config.bulletSpeed;
                this.owner = owner;
                this.active = true;
                this.radius = 8;
            }

            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.active = false;
                }
            }

            draw() {
                ctx.save();
                const color = this.owner === 1 ? '#60a5fa' : this.owner === 2 ? '#f87171' : '#fbbf24';
                ctx.fillStyle = color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        // Clase PowerUp
        class PowerUp {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 30;
                const types = ['health', 'speed', 'rapidFire', 'shield'];
                this.type = types[Math.floor(Math.random() * types.length)];
                this.active = true;
                this.rotation = 0;
            }

            update() {
                this.rotation += 0.08;
            }

            getColor() {
                switch (this.type) {
                    case 'health': return '#22c55e';
                    case 'speed': return '#3b82f6';
                    case 'rapidFire': return '#f59e0b';
                    case 'shield': return '#a855f7';
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.getColor();
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.getColor();
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5;
                    const radius = i % 2 === 0 ? this.size : this.size / 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            }

            applyEffect(ship) {
                switch (this.type) {
                    case 'health':
                        ship.health = Math.min(ship.maxHealth, ship.health + 30);
                        break;
                    case 'speed':
                        ship.tempSpeed = ship.speed * 1.6;
                        setTimeout(() => { ship.tempSpeed = null; }, 5000);
                        break;
                    case 'rapidFire':
                        ship.tempFireRate = config.fireRate / 2.5;
                        setTimeout(() => { ship.tempFireRate = null; }, 5000);
                        break;
                    case 'shield':
                        ship.shield = true;
                        setTimeout(() => { ship.shield = false; }, 5000);
                        break;
                }
            }
        }

        // Clase Obstacle
        class Obstacle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 35 + 30;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotSpeed = (Math.random() - 0.5) * 0.03;
            }

            update() {
                this.rotation += this.rotSpeed;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = '#475569';
                ctx.strokeStyle = '#1e293b';
                ctx.lineWidth = 4;
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI * 2) / 8;
                    const radius = this.size * (0.7 + Math.random() * 0.6);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('âš ', 0, 0);
                ctx.restore();
            }
        }

        // Clase Enemy
        class Enemy {
            constructor() {
                const side = Math.floor(Math.random() * 4);
                switch(side) {
                    case 0: this.x = Math.random() * canvas.width; this.y = -60; break;
                    case 1: this.x = canvas.width + 60; this.y = Math.random() * canvas.height; break;
                    case 2: this.x = Math.random() * canvas.width; this.y = canvas.height + 60; break;
                    case 3: this.x = -60; this.y = Math.random() * canvas.height; break;
                }
                this.size = 45;
                this.health = 30;
                this.speed = 2;
                this.angle = 0;
                this.bullets = [];
                this.lastShot = 0;
                this.active = true;
            }

            update(target) {
                if (!target) return;
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    this.angle = Math.atan2(dy, dx);
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                if (dist < 500 && Date.now() - this.lastShot > 1200) {
                    this.bullets.push(new Bullet(this.x, this.y, this.angle, 'enemy'));
                    this.lastShot = Date.now();
                }
                this.bullets = this.bullets.filter(b => b.active);
                this.bullets.forEach(b => b.update());
            }

            takeDamage(dmg) {
                this.health -= dmg;
                if (this.health <= 0) {
                    this.active = false;
                    enemiesKilled++;
                    score += 100;
                    if (Math.random() < 0.4) {
                        powerUps.push(new PowerUp(this.x, this.y));
                    }
                    for (let i = 0; i < 20; i++) {
                        particles.push(new Particle(this.x, this.y, '#ff6b6b'));
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = '#dc2626';
                ctx.strokeStyle = '#991b1b';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#dc2626';
                ctx.beginPath();
                ctx.moveTo(this.size * 0.6, 0);
                ctx.lineTo(-this.size * 0.4, -this.size * 0.4);
                ctx.lineTo(-this.size * 0.6, 0);
                ctx.lineTo(-this.size * 0.4, this.size * 0.4);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#374151';
                ctx.fillRect(this.size * 0.2, -6, this.size * 0.3, 12);
                ctx.restore();
                this.bullets.forEach(b => b.draw());
            }
        }

        // Clase Ship
        class Ship {
            constructor(x, y, player, color) {
                this.x = x;
                this.y = y;
                this.player = player;
                this.color = color;
                this.angle = player === 2 ? Math.PI : 0;
                this.size = 50;
                this.speed = config.shipSpeed;
                this.health = 100;
                this.maxHealth = 100;
                this.bullets = [];
                this.lastShot = 0;
                this.shield = false;
                this.tempSpeed = null;
                this.tempFireRate = null;
            }

            move(dx, dy) {
                const spd = this.tempSpeed || this.speed;
                this.x += dx * spd;
                this.y += dy * spd;
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
                if (dx !== 0 || dy !== 0) {
                    this.angle = Math.atan2(dy, dx);
                }
            }

            shoot() {
                const fr = this.tempFireRate || config.fireRate;
                if (Date.now() - this.lastShot > fr) {
                    this.bullets.push(new Bullet(
                        this.x + Math.cos(this.angle) * this.size,
                        this.y + Math.sin(this.angle) * this.size,
                        this.angle,
                        this.player
                    ));
                    this.lastShot = Date.now();
                }
            }

            takeDamage(dmg) {
                if (this.shield) {
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(this.x, this.y, '#a855f7'));
                    }
                    return;
                }
                this.health -= dmg;
                if (this.health < 0) this.health = 0;
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(this.x, this.y, '#fbbf24'));
                }
            }

            update() {
                this.bullets = this.bullets.filter(b => b.active);
                this.bullets.forEach(b => b.update());
            }

            draw() {
                // Escudo
                if (this.shield) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 1.3, 0, Math.PI * 2);
                    ctx.strokeStyle = '#a855f7';
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = 0.6;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Barco
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Sombra
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                
                // Cuerpo principal
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.player === 1 ? '#1e40af' : '#991b1b';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(this.size * 0.7, 0);
                ctx.lineTo(-this.size * 0.5, -this.size * 0.45);
                ctx.lineTo(-this.size * 0.7, 0);
                ctx.lineTo(-this.size * 0.5, this.size * 0.45);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Cabina
                ctx.shadowBlur = 0;
                ctx.fillStyle = this.player === 1 ? '#1e40af' : '#991b1b';
                ctx.fillRect(-this.size * 0.25, -this.size * 0.25, this.size * 0.5, this.size * 0.5);
                
                // CaÃ±Ã³n
                ctx.fillStyle = '#374151';
                ctx.fillRect(this.size * 0.3, -8, this.size * 0.4, 16);
                
                ctx.restore();

                // Estela
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(
                    this.x - Math.cos(this.angle) * this.size * 0.7,
                    this.y - Math.sin(this.angle) * this.size * 0.7,
                    this.size * 0.35,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                ctx.globalAlpha = 1;

                // Balas
                this.bullets.forEach(b => b.draw());
            }
        }

        // Controles
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && gameActive) {
                e.preventDefault();
                if (player1) player1.shoot();
            }
            if (e.key === 'Enter' && gameActive && gameMode === 'multi') {
                e.preventDefault();
                if (player2) player2.shoot();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function startGame(mode) {
            gameMode = mode;
            gameActive = true;
            score = 0;
            enemiesKilled = 0;

            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('controls').style.display = 'block';

            if (mode === 'single') {
                document.getElementById('ui').style.display = 'none';
                document.getElementById('score').style.display = 'block';
                document.getElementById('controls1J').style.display = 'block';
                document.getElementById('controls2J').style.display = 'none';
                player1 = new Ship(canvas.width / 2, canvas.height / 2, 1, '#3b82f6');
                player2 = null;
            } else {
                document.getElementById('ui').style.display = 'flex';
                document.getElementById('player2Info').style.display = 'block';
                document.getElementById('score').style.display = 'none';
                document.getElementById('controls1J').style.display = 'none';
                document.getElementById('controls2J').style.display = 'block';
                player1 = new Ship(canvas.width * 0.25, canvas.height / 2, 1, '#3b82f6');
                player2 = new Ship(canvas.width * 0.75, canvas.height / 2, 2, '#ef4444');
            }

            enemies = [];
            obstacles = [];
            for (let i = 0; i < 10; i++) {
                obstacles.push(new Obstacle());
            }
            powerUps = [];
            particles = [];
            lastEnemySpawn = Date.now();
            lastPowerUpSpawn = Date.now();

            updateUI();
        }

        function backToMenu() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('menuScreen').style.display = 'block';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('score').style.display = 'none';
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            startGame(gameMode);
        }

        function updateUI() {
            if (player1) {
                document.getElementById('p1Health').textContent = Math.ceil(player1.health);
                document.getElementById('p1HealthBar').style.width = player1.health + '%';
            }
            if (player2) {
                document.getElementById('p2Health').textContent = Math.ceil(player2.health);
                document.getElementById('p2HealthBar').style.width = player2.health + '%';
            }
            document.getElementById('scoreValue').textContent = score;
            document.getElementById('enemiesKilled').textContent = enemiesKilled;

            if (player1 && player1.health <= 0) endGame();
            if (player2 && player2.health <= 0) endGame();
        }

        function endGame() {
            gameActive = false;
            if (gameMode === 'single') {
                document.getElementById('winnerText').textContent = 'Â¡GAME OVER!';
                document.getElementById('gameOverStats').textContent = 
                    `PuntuaciÃ³n: ${score} | Enemigos Derrotados: ${enemiesKilled}`;
            } else {
                const winner = player1.health > 0 ? 'Jugador 1' : 'Jugador 2';
                document.getElementById('winnerText').textContent = `Â¡${winner} Gana!`;
                document.getElementById('gameOverStats').textContent = 'Â¡Partida terminada!';
            }
            document.getElementById('gameOver').style.display = 'block';
        }

        function checkCollisions() {
            // Power-ups
            powerUps = powerUps.filter(p => {
                if (player1) {
                    const d1 = Math.hypot(p.x - player1.x, p.y - player1.y);
                    if (d1 < player1.size + p.size) {
                        p.applyEffect(player1);
                        score += 50;
                        return false;
                    }
                }
                if (player2) {
                    const d2 = Math.hypot(p.x - player2.x, p.y - player2.y);
                    if (d2 < player2.size + p.size) {
                        p.applyEffect(player2);
                        return false;
                    }
                }
                return p.active;
            });

            // ObstÃ¡culos
            obstacles.forEach(obs => {
                if (player1) {
                    const d1 = Math.hypot(obs.x - player1.x, obs.y - player1.y);
                    if (d1 < obs.size + player1.size / 2) {
                        player1.takeDamage(5);
                        const angle = Math.atan2(player1.y - obs.y, player1.x - obs.x);
                        player1.x += Math.cos(angle) * 8;
                        player1.y += Math.sin(angle) * 8;
                    }
                }
                if (player2) {
                    const d2 = Math.hypot(obs.x - player2.x, obs.y - player2.y);
                    if (d2 < obs.size + player2.size / 2) {
                        player2.takeDamage(5);
                        const angle = Math.atan2(player2.y - obs.y, player2.x - obs.x);
                        player2.x += Math.cos(angle) * 8;
                        player2.y += Math.sin(angle) * 8;
                    }
                }
            });

            if (gameMode === 'single') {
                // Balas jugador vs enemigos
                if (player1) {
                    player1.bullets.forEach(b => {
                        enemies.forEach(e => {
                            if (b.active && e.active && Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
                                b.active = false;
                                e.takeDamage(config.bulletDamage);
                            }
                        });
                    });
                }
                // Balas enemigos vs jugador
                enemies.forEach(e => {
                    e.bullets.forEach(b => {
                        if (player1 && b.active && Math.hypot(b.x - player1.x, b.y - player1.y) < player1.size) {
                            b.active = false;
                            player1.takeDamage(config.bulletDamage);
                        }
                    });
                });
            } else {
                // PvP
                if (player1 && player2) {
                    player1.bullets.forEach(b => {
                        if (b.active && Math.hypot(b.x - player2.x, b.y - player2.y) < player2.size) {
                            b.active = false;
                            player2.takeDamage(config.bulletDamage);
                        }
                    });
                    player2.bullets.forEach(b => {
                        if (b.active && Math.hypot(b.x - player1.x, b.y - player1.y) < player1.size) {
                            b.active = false;
                            player1.takeDamage(config.bulletDamage);
                        }
                    });
                }
            }
        }

        function gameLoop() {
            // Fondo
            ctx.fillStyle = '#0a4d68';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Olas
            const time = Date.now() * 0.001;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 15) {
                    const y = canvas.height * 0.4 + Math.sin(x * 0.008 + time + i * 0.7) * 25;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            if (gameActive) {
                // Controles P1
                if (player1) {
                    let dx = 0, dy = 0;
                    if (keys['w']) dy -= 1;
                    if (keys['s']) dy += 1;
                    if (keys['a']) dx -= 1;
                    if (keys['d']) dx += 1;
                    if (dx || dy) player1.move(dx, dy);
                    player1.update();
                }

                // Controles P2
                if (player2) {
                    let dx = 0, dy = 0;
                    if (keys['arrowup']) dy -= 1;
                    if (keys['arrowdown']) dy += 1;
                    if (keys['arrowleft']) dx -= 1;
                    if (keys['arrowright']) dx += 1;
                    if (dx || dy) player2.move(dx, dy);
                    player2.update();
                }

                // Spawns
                if (gameMode === 'single' && Date.now() - lastEnemySpawn > config.enemySpawnRate) {
                    enemies.push(new Enemy());
                    lastEnemySpawn = Date.now();
                }
                if (Date.now() - lastPowerUpSpawn > config.powerUpSpawnRate) {
                    powerUps.push(new PowerUp(
                        Math.random() * (canvas.width - 100) + 50,
                        Math.random() * (canvas.height - 100) + 50
                    ));
                    lastPowerUpSpawn = Date.now();
                }

                // Updates
                obstacles.forEach(o => o.update());
                powerUps.forEach(p => p.update());
                enemies = enemies.filter(e => e.active);
                enemies.forEach(e => e.update(player1));
                particles = particles.filter(p => p.life > 0);
                particles.forEach(p => p.update());
                checkCollisions();
                updateUI();
            }

            // Draw
            obstacles.forEach(o => o.draw());
            powerUps.forEach(p => p.draw());
            enemies.forEach(e => e.draw());
            particles.forEach(p => p.draw());
            if (player1) player1.draw();
            if (player2) player2.draw();

            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        gameLoop();
    </script>
</body>
</html>